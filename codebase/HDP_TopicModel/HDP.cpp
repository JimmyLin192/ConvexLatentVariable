/*###############################################################
## MODULE: HDP.cpp
## VERSION: 1.0 
## SINCE 2014-07-21
## AUTHOR:
##     Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
##
## DESCRIPTION: 
##     Convex relaxation for HDP resolution
################################################################# 
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include "HDP.h"
#include "exSparseMat.h"
#include <cassert>

/* algorithmic options */ 
#define EXACT_LINE_SEARCH  // comment this to use inexact search

/* dumping options */
// #define FRANK_WOLFE_DUMP
// #define EXACT_LINE_SEARCH_DUMP
// #define BLOCKWISE_DUMP
// #define NTOPIC_DUMP


double sign (int input) {

    if (input > 0) return 1.0;
    else if ( input < 0 ) return -1.0;
    else return 0.0;

}

bool pairComparator (const std::pair<int, double>& firstElem, const std::pair<int, double>& secondElem) {
    // sort pairs by second element with *decreasing order*
    return firstElem.second > secondElem.second;
}

typedef double (* dist_func) (Instance*, Instance*, int); 
const double r = 1000.0;

int get_nCentroids (double ** W, int nRows, int nCols) {

    int nTopics = 0;

/*{{{*/
    /*
    double * sum_belonging = new double [nCols];

    mat_max_col (W, sum_belonging, nRows, nCols);

    for (int i = 0; i < nCols; i ++ ) {
        if (sum_belonging[i] > 3e-1) { 
            nCentroids ++;
        }
    }
    
    delete[] sum_belonging;
    */
/*}}}*/

    return nTopics;
}

vector<int> get_all_centroids(double ** W, int nRows, int nCols) {

    std::vector<int> topics;

/*{{{*/
    /*
    double * sum_belonging = new double [nCols];
    for (int i = 0; i < nCols; i ++) {
        sum_belonging[i] = 0.0;
    }

    mat_max_col (W, sum_belonging, nRows, nCols);

    for (int i = 0; i < nCols; i ++ ) {
        if (sum_belonging[i] > 3e-1) {
            centroids.push_back(i);
        }
    }
    
    delete[] sum_belonging;
    */
/*}}}*/

    return topics;
}

double first_subproblm_obj (double ** dist_mat, double ** yone, double ** zone, double ** wone, double rho, int N) {

    double ** temp = mat_init (N, N);
    double ** diffone =mat_init (N, N);
    mat_zeros (diffone, N, N);

    // sum1 = 0.5 * sum_n sum_k (w_nk * d^2_nk) -> loss
    mat_zeros (temp, N, N);
    mat_times (wone, dist_mat, temp, N, N);
    double sum1 = 0.5 * mat_sum (temp, N, N);

    // sum2 = y_1^T dot (w_1 - z) -> linear
    mat_zeros (temp, N, N);
    mat_sub (wone, zone, diffone, N, N); // temp = w_1 - z_1
    mat_tdot (yone, diffone, temp, N, N);
    double sum2 = mat_sum (temp, N, N);

    // sum3 = 0.5 * rho * || w_1 - z_1 ||^2 -> quadratic
    mat_zeros (temp, N, N);
    mat_sub (wone, zone, temp, N, N);
    double sum3 = 0.5 * rho * mat_norm2 (temp, N, N);

    // sum4 = r dot (1 - sum_k w_nk) -> dummy
    double * temp_vec = new double [N];
    mat_sum_row (wone, temp_vec, N, N);
    double dummy_penalty = 0.0;
    for (int i = 0; i < N; i ++) {
        dummy_penalty += r*(1 - temp_vec[i]);
    }
    double total = sum1+sum2+sum3+dummy_penalty;
    /*
#ifdef FRANK_WOLFE_DUMP
    cout << "[Frank_wolfe] (loss, linear, quadratic, dummy, total) = (" 
         << sum1 << ", " << sum2 << ", " << sum3 << ", " << dummy_penalty << ", " << total
         <<  ")" << endl;
#endif
*/

    mat_free (temp, N, N);
    mat_free (diffone, N, N);
    delete [] temp_vec;

    return total;
}

void frank_wolfe_solver (double ** MATCH_MAT, double ** Y_1, double ** Z_1, double ** w_1, double RHO, int N) {

    bool is_global_optimal_reached = false;

    // cout << "within frank_wolfe_solver" << endl;
    // This can be computed by using corner point. 
    double ** gradient = mat_init (N, N);
    double ** s = mat_init (N, N);
    mat_zeros (gradient, N, N);

#ifndef EXACT_LINE_SEARCH
    int K = 300;
#else
    int K = 2;
    double ** w_minus_s = mat_init (N, N);
    double ** w_minus_z = mat_init (N, N);
#endif

    int k = 0; // iteration number
    double gamma; // step size
    double penalty;
    double ** tempS = mat_init (N, N);

    //mat_zeros (w_1, N, N);
    double sum1, sum2, sum3, sum4;
    // cout << "within frank_wolfe_solver: start iteration" << endl;
    while (k < K && !is_global_optimal_reached) {
        // STEP ONE: find s minimize <s, grad f>
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                gradient[i][j] =  0.5*MATCH_MAT[i][j] + Y_1[i][j] + RHO * (w_1[i][j] - Z_1[i][j]) ;  //- r[i];
            }
        }
        mat_zeros (s, N, N);
        mat_min_row (gradient, s, N, N);

        /*
#ifdef FRANK_WOLFE_DUMP
        cout << "mat_norm2 (w_1, N, N): " <<  mat_norm2 (w_1, N, N) << endl;
        cout << "mat_norm2 (Y_1, N, N): " <<  mat_norm2 (Y_1, N, N) << endl;
        cout << "mat_norm2 (gradient, N, N): " <<  mat_norm2 (gradient, N, N) << endl;
        cout << "mat_sum (s, N, N): " <<  mat_sum (s, N, N) << endl;
#endif
*/
        // cout << "within frank_wolfe_solver: step one finished" << endl;

        // STEP TWO: apply exact or inexact line search to find solution
#ifndef EXACT_LINE_SEARCH
        // Here we use inexact line search
        gamma = 2.0 / (k + 2.0);
#else
        // Here we use exact line search 
        if (k == 0) {
            gamma = 1.0;
        } else {
        // gamma* = (sum1 + sum2 + sum3) / sum4, where
        // sum1 = 1/2 sum_n sum_k (w - s)_nk * || x_n - mu_k ||^2
        // sum2 = sum_n sum_k (w - s)_nk
        // sum3 = - RHO * sum_n sum_k  (w - z) 
        // sum4 = sum_n sum_k RHO * (s - w)
        mat_zeros (tempS, N, N);
        mat_zeros (w_minus_s, N, N);
        mat_zeros (w_minus_z, N, N);
        mat_sub (w_1, s, w_minus_s, N, N);
        mat_sub (w_1, Z_1, w_minus_z, N, N);

        // NOTE: in case of ||w_1 - s||^2 = 0, not need to optimize anymore
        // since incremental term = w + gamma (s - w), and whatever gamma is,
        // w^(k+1) = w^(k), this would be equivalent to gamma = 0
        if (mat_norm2(w_minus_s, N, N) == 0) {
            gamma = 0;
            is_global_optimal_reached = true;
        } else {
            mat_times (w_minus_s, dist_mat, tempS, N, N);
            sum1 = 0.5 * mat_sum (tempS, N, N);

            mat_zeros (tempS, N, N);
            mat_tdot (Y_1, w_minus_s, tempS, N, N);
            sum2 = mat_sum (tempS, N, N);
 
            mat_zeros (tempS, N, N);
            mat_tdot (w_minus_z, w_minus_s, tempS, N, N);
            sum3 = RHO * mat_sum (tempS, N, N);

            mat_zeros (tempS, N, N);
            sum4 = RHO * mat_norm2 (w_minus_s, N, N);

            // gamma should be within interval [0,1]
            gamma = (sum1 + sum2 + sum3) / sum4;

#ifdef FRANK_WOLFE_DUMP
            cout << "mat_norm2 (w_minus_s, N, N)" << mat_norm2 (w_minus_s, N, N) << endl;
            cout << "mat_norm2 (w_minus_z, N, N)" << mat_norm2 (w_minus_z, N, N) << endl;
#endif
            // cout << "within frank_wolfe_solver: step two finished" << endl;

#ifdef EXACT_LINE_SEARCH_DUMP
            cout << "[exact line search] (sum1, sum2, sum3, sum4, gamma) = ("
                << sum1 << ", " << sum2 << ", " << sum3 << ", " << sum4 << ", " << gamma
                << ")"
                << endl;
#endif
        }

        }
#endif
        // update the w^(k+1)
        mat_zeros (tempS, N, N);
        mat_dot (gamma, s, tempS, N, N);
        mat_dot (1.0-gamma, w_1, w_1, N, N);
        mat_add (w_1, tempS, w_1, N, N);

        // compute value of objective function
        penalty = first_subproblm_obj (dist_mat, Y_1, Z_1, w_1, RHO, N);
        // cout << "within frank_wolfe_solver: step three finished" << endl;
        // report the #iter and objective function
        /*
           cout << "[Frank-Wolfe] iteration: " << k << ", first_subpro_obj: " << penalty << endl;
        */

        k ++;
    // cout << "within frank_wolfe_solver: next iteration" << endl;
    }
    // cout << "within frank_wolfe_solver: to free gradient" << endl;
    mat_free (gradient, N, N);
    // cout << "within frank_wolfe_solver: to free temps" << endl;
    mat_free (tempS, N, N);
    // cout << "within frank_wolfe_solver: to free s " << endl;
    mat_free (s, N, N);
    // cout << "end frank_wolfe_solver: finished! " << endl;
}


double second_subproblem_obj (double ** ytwo, double ** z, double ** wtwo, double rho, int N, double lambda) {

    double ** temp = mat_init (N, N);
    double ** difftwo = mat_init (N, N);
    mat_zeros (difftwo, N, N);

    // reg = 0.5 * sum_k max_n | w_nk |  -> group-lasso
    mat_zeros (temp, N, N);
    double * maxn = new double [N]; 
    for (int i = 0; i < N; i ++) { // Ian: need initial 
        maxn[i] = -INF;
    }

    for (int i = 0; i < N; i ++) {
        for (int j = 0; j < N; j ++) {
            if (wtwo[i][j] > maxn[j])
                maxn[j] = wtwo[i][j];
        }
    }
    double sumk = 0.0;
    for (int i = 0; i < N; i ++) {
        sumk += maxn[i];
    }
    double group_lasso = lambda * sumk; 

    // sum2 = y_2^T dot (w_2 - z) -> linear
    mat_zeros (temp, N, N);
    mat_sub (ytwo, z, difftwo, N, N);
    mat_tdot (ytwo, difftwo, temp, N, N);
    double sum2 = mat_sum (temp, N, N);

    // sum3 = 0.5 * rho * || w_2 - z_2 ||^2 -> quadratic mat_zeros (temp, N, N);
    mat_sub (wtwo, z, temp, N, N);
    double sum3 = 0.5 * rho * mat_norm2 (temp, N, N);

    mat_free (temp, N, N);

    // ouput values of each components
#ifdef BLOCKWISE_DUMP
    cout << "[Blockwise] (group_lasso, linear, quadratic) = ("
        << group_lasso << ", " << sum2 << ", " << sum3
        << ")" << endl;
#endif

    //cerr << group_lasso << ", " << sum2 << ", " << sum3 << endl;
    return group_lasso + sum2 + sum3;
}

void group_lasso_solver (double ** ytwo, double ** ztwo, double ** wtwo, double rho, double lambda, int N) {

    // STEP ONE: compute the optimal solution for truncated problem
    double ** wbar = mat_init (N, N);
    mat_zeros (wbar, N, N);
    mat_dot (rho, ztwo, wbar, N, N); // wbar = rho * z_2
    mat_sub (wbar, ytwo, wbar, N, N); // wbar = rho * z_2 - y_2
    mat_dot (1.0/rho, wbar, wbar, N, N); // wbar = (rho * z_2 - y_2) / rho

    // STEP TWO: find the closed-form solution for second subproblem
    for (int j = 0; j < N; j ++) {
        // 1. bifurcate the set of values
        vector< pair<int,double> > alpha_vec;
        for (int i = 0; i < N; i ++) {
            double value = wbar[i][j];
            /*if( wbar[i][j] < 0 ){
              cerr << "wbar[" << i << "][" << j << "]" << endl;
              exit(0);
              }*/
            alpha_vec.push_back (make_pair(i, abs(value)));
        }

        // 2. sorting
        std::sort (alpha_vec.begin(), alpha_vec.end(), pairComparator);
        /*
           for (int i = 0; i < N; i ++) {
           if (alpha_vec[i].second != 0)
           cout << alpha_vec[i].second << endl;
           }
           */

        // 3. find mstar
        int mstar = 0; // number of elements support the sky
        double separator;
        double max_term = -INF, new_term;
        double sum_alpha = 0.0;
        for (int i = 0; i < N; i ++) {
            sum_alpha += alpha_vec[i].second;
            new_term = (sum_alpha - lambda) / (i + 1.0);
            if ( new_term > max_term ) {
                separator = alpha_vec[i].second;
                max_term = new_term;
                mstar = i;
            }
        }

        // 4. assign closed-form solution to wtwo
        if( max_term < 0 ){
            for(int i=0;i<N;i++)
                wtwo[i][j] = 0.0;
            continue;
        }

        for (int i = 0; i < N; i ++) {
            // harness vector of pair
            double value = wbar[i][j];
            if ( abs(value) >= separator ) {
                wtwo[i][j] = max_term;
            } else {
                // its ranking is above m*, directly inherit the wbar
                wtwo[i][j] = max(wbar[i][j],0.0);
            }
        }
    }

    // compute value of objective function
    double penalty = second_subproblem_obj (ytwo, ztwo, wtwo, rho, N, lambda);
    // report the #iter and objective function
    /*cout << "[Blockwise] second_subproblem_obj: " << penalty << endl;
      cout << endl;*/

    // STEP THREE: recollect temporary variable - wbar
    mat_free (wbar, N, N);
}

/* TODO: 
    1. clarify the definition of new loss
    2. extend opt_objective to three regularizers (data structure dependent) 
*/
double opt_objective (double ** dist_mat, double lambda, int N, double ** z) {
    // N is number of entities in "data", and z is N by N.
    // z is current valid solution (average of w_1 and w_2)
    
    double sum = 0.0;
    for(int i=0;i<N;i++)
	    for(int j=0;j<N;j++)
		    sum += z[i][j];
    cerr << "sum=" << sum/N << endl;

    // STEP ONE: compute loss function
    double normSum = 0.0;
    for (int i = 0; i < N; i ++) {
        for (int j = 0; j < N; j ++) {
            normSum += z[i][j] * dist_mat[i][j];
        }
    }
    
    // sum4 = r dot (1 - sum_k w_nk) -> dummy
    double * temp_vec = new double [N];
    mat_sum_row (z, temp_vec, N, N);
    //double dummy_penalty=0.0;
    double avg=0.0;
    for (int i = 0; i < N; i ++) {
        avg += temp_vec[i];
        //dummy_penalty += r * max(1 - temp_vec[i], 0.0) ;
    }
    
    double loss = 0.5 * (normSum/*+dummy_penalty*/);
    cout << "loss=" << loss << endl;

    // STEP TWO: compute group-lasso regularization
    double * maxn = new double [N]; 
    for (int i = 0;i < N; i ++) { // Ian: need initial 
        maxn[i] = -INF;
    }

    for (int i = 0; i < N; i ++) {
        for (int j = 0; j < N; j ++) {
            if ( fabs(z[i][j]) > maxn[j])
                maxn[j] = fabs(z[i][j]);
        }
    }
    double sumk = 0.0;
    for (int i = 0; i < N; i ++) {
        sumk += maxn[i];
    }
    double reg = lambda * sumk; 
    cout << "reg=" << reg << endl;

    //delete[] temp_vec;
    return loss + reg;
}

/* Compute the mutual distance of input instances contained within "data" */
void compute_match_mat (vector<Instance*>& data, double ** dist_mat, int N, int D, dist_func df, bool isSym) {

    // STEP ONE: convert input sparse data to desired format
    for (int i = 0; i < N; i ++) {
        for (int j = 0; j < N; j ++) {
            ;
        }
    }

    // STEP two: check correctness by assertion
    

}

void HDP ( double ** dist_mat, int D, int N, vector<double> LAMBDAs, double ** W) {

    // SET MODEL-RELEVANT PARAMETERS 
    assert (LAMBDAs.size == 2);
    double LABMDA_DOC = LAMBDAs[0];
    double LAMBDA_TOPIC = LAMBDAs[1];
    double LAMBDA_BLOCK = LAMBDAs[2];
    double ALPHA = 1.0;
    double RHO = 1.0;

    /* DECLARE AND INITIALIZE INVOLVED VARIABLES AND MATRICES */
    Esmat* w_1 = esmat_init (N, N);
    Esmat* w_2 = esmat_init (N, N);
    Esmat* w_3 = esmat_init (N, N);
    Esmat* w_4 = esmat_init (N, N);

    Esmat* y_1 = esmat_init (N, N);
    Esmat* y_2 = esmat_init (N, N);
    Esmat* y_3 = esmat_init (N, N);
    Esmat* y_4 = esmat_init (N, N);

    Esmat* z = esmat_init (N, N);

    Esmat* diff_1 = esmat_init (N, N);
    Esmat* diff_2 = esmat_init (N, N);
    Esmat* diff_3 = esmat_init (N, N);
    Esmat* diff_4 = esmat_init (N, N);

    /* SET ITERATION-RELEVANT VARIABLES */
    double error = INF;
    int iter = 0; 
    int max_iter = 2000;

    /* ITERATIVE OPTIMIZATION */
    while ( iter < max_iter ) { // STOPPING CRITERIA
        // STEP ZERO: RESET ALL SUBPROBLEM SOLUTIONS (OPTIONAL) 
        esmat_zeros (w_1);
        esmat_zeros (w_2);
        esmat_zeros (w_3);
        esmat_zeros (w_4);

        /*
#ifdef ITERATION_TRACE_DUMP
        cout << "it is place 0 iteration #" << iter << ", going to get into frank_wolfe_solvere"  << endl;
#endif
*/

        // STEP ONE: RESOLVE W_1, W_2, W_3, W_4
        // resolve w_1
        frank_wolfe_solver (dist_mat, y_1, z, w_1, rho, N); 

        /*
#ifdef ITERATION_TRACE_DUMP
        cout << "frank_wolfe_solver done. norm2(w_1) = " << mat_norm2 (wone, N, N) << endl;
        cout << "it is place 1 iteration #" << iter << ", going to get into group_lasso_solver"<< endl;
#endif
*/

        // resolve w_2
        group_lasso_solver (y_2, z, w_2, RHO, lambda, N);
        /*
#ifdef ITERATION_TRACE_DUMP
        cout << "it is place 3 iteration #" << iter << endl;
        cout << "norm2(w_2) = " << mat_norm2 (wtwo, N, N) << endl;
#endif
*/
        // resolve w_3
        group_lasso_solver (y_3, z, w_3, RHO, lambda, N);
        // resolve w_4
        group_lasso_solver (y_4, z, w_4, RHO, lambda, N);
        
        // STEP TWO: update z by averaging w_1, w_2, w_3 and w_4
        temp = esmat_init ();
        esmat_add (w_1, w_2, z);
        esmat_copy (z, temp);
        esmat_add (temp, w_3, z);
        esmat_copy (z, temp);
        esmat_add (temp, w_4, z);
        esmat_scalar_mult (0.25, z);

        /*
#ifdef ITERATION_TRACE_DUMP
        cout << "it is place 4 iteration #" << iter << endl;
        cout << "norm2(z) = " << mat_norm2 (z, N, N) << endl;
#endif
*/

        // STEP THREE: update the y_1 and y_2 by w_1, w_2 and z
        esmat_sub (w_1, z, diff_1);
        // double trace_wone_minus_z = esmat_norm2 (diff_1); 
        esmat_scalar_mult (ALPHA, diff_1);
        esmat_copy (y_1, temp);
        esmat_add (temp, diff_1, y_1);

        esmat_sub (w_2, z, diff_2);
        //double trace_wtwo_minus_z = esmat_norm2 (diff_2); 
        esmat_scalar_mult (ALPHA, diff_2);
        esmat_copy (y_2, temp);
        esmat_add (temp, diff_2, y_2);

        esmat_sub (w_3, z, diff_3);
        //double trace_wthree_minus_z = esmat_norm2 (diff_3); 
        esmat_scalar_mult (ALPHA, diff_3);
        esmat_copy (y_3, temp);
        esmat_add (temp, diff_3, y_3);

        esmat_sub (w_4, z, diff_4);
        //double trace_wfour_minus_z = esmat_norm2 (diff_4); 
        esmat_scalar_mult (ALPHA, diff_4);
        esmat_copy (y_4, temp);
        esmat_add (temp, diff_4, y_4);

        // STEP FOUR: trace the objective function
        /*
        if (iter % 1 == 0) {
            // 1. trace the error
            error = opt_objective (dist_mat, lambda, N, z);
            cout << "[Overall] iter = " << iter 
                 << ", Overall Error: " << error;
            /
#ifdef NTOPIC_DUMP
            // 2. get number of topic
            int nTopics = get_nTopics(z, N, N);
            cout << ", nTopics: " << nTopics;
#endif
            cout << endl;
        }
        */

        iter ++;
    }
    
    // STEP FIVE: memory recollection
    esmat_free (w_1);
    esmat_free (w_2);
    esmat_free (w_3);
    esmat_free (w_4);

    esmat_free (y_1);
    esmat_free (y_2);
    esmat_free (y_3);
    esmat_free (y_4);

    esmat_free (diff_1);
    esmat_free (diff_2);
    esmat_free (diff_3);
    esmat_free (diff_4);
    // STEP SIX: put converged solution to destinated W
    esmat_copy (z, W);
    esmat_free (z);
}

// entry main function
int main (int argc, char ** argv) {

    // EXCEPTION control: illustrate the usage if get input of wrong format
    if (argc < 3) {
        cerr << "Usage: HDP [dataFile] [lambda_document] [lambda_topic] [lambda_block]" << endl;
        cerr << "Note: dataFile must be scaled to [0,1] in advance." << endl;
        exit(-1);
    }

    // PARSE arguments
    char * dataFile = argv[1];
    vector<double> LAMBDAs (3, 0.0);
    LAMBDAs[0] = atof(argv[2]); // lambda_document
    LAMBDAs[1] = atof(argv[3]); // lambda_topic
    LAMBDAs[2] = atof(argv[4]); // lambda_block

    // READ in data
    vector<Instance*> data;
    //read2D (dataFile, data);  
    // NOTE: need to change the number once switch to a new dataset
    readFixDim (dataFile, data, 13);

    // EDA: explore the data 
    int dimensions = -1;
    int N = data.size(); // data size
    for (int i = 0; i < N; i++) {
        vector< pair<int,double> > * f = &(data[i]->fea);
        int last_index = f->size() - 1;
        if (f->at(last_index).first > dimensions) {
            dimensions = f->at(last_index).first;
        }
    }
    int D = dimensions;
    cerr << "D = " << D << endl; // # features
    cerr << "N = " << N << endl; // # instances
    cerr << "lambda = " << lambda << endl;
    cerr << "r = " << r << endl;

    int seed = time(NULL);
    srand (seed);
    cerr << "seed = " << seed << endl;

    // restore matchness matrix in sparse representation
    /* here we consider non-noise version of topic model
    double ** match_mat = mat_init (N, N);
    mat_zeros (match_mat, N, N);
    */

    // Run sparse convex clustering
    Esmat* W = mat_init (N, N);
    mat_zeros (W, N, N);
    HDP (dist_mat, D, N, lambda, W);

    // Output results
    ofstream fout("result");

    // get all topics
    /*{{{*/
    /*
    vector<int> centroids = get_all_centroids(W, N, N); // contains index of all centroids
    
    int nCentroids = centroids.size();
    for (int i = 0; i < N; i ++) {
        // output identification and its belonging
        fout << "id=" << i+1 << ", fea[0]=" << data[i]->fea[0].second << ", ";  // sample id
        for (int j = 0; j < N; j ++) {
            if( fabs(W[i][j]) > 3e-1 ) {
                fout << j+1 << "(" << W[i][j] << "),\t";
            }
        }
	fout << endl;

        // output distance of one sample to each centroid 
        fout << "dist_centroids: (";
        for (int j = 0; j < nCentroids - 1; j ++) {
            fout << dist_mat[i][ centroids[j] ] << ", ";
        }
        fout << dist_mat[i][ centroids[nCentroids-1] ] << ")";
        fout << endl;
    }
    */
/*}}}*/
}
