/*###############################################################
## MODULE: exSparseMat.h
## VERSION: 1.0 
## SINCE: 2014-07-24
## AUTHOR: Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
## DESCRIPTION: 
##     Header file for Extensible Sparse matrix  
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/


typedef struct {
        int nRows;
        int nCols;
        vector< pair<int, double> > val;
} Esmat;

/* Initialize one extensible sparse matrix with all zero entries */
Esmat esmat_init (int nRows, int nCols) {

    Esmat freshman = new Esmat ();
    freshman.nRows = nRows;
    freshman.nCols = nCols;
    freshman.val = new vector< pair<int, double> > ();

    return freshman;
}

void esmat_free (Esmat src) {

    delete src.val;
    delete Esmat;

}

/* Add two extensible sparse matrices */
void esmat_add (Esmat A, Esmat B, Esmat dest) {
    
    assert (esmat_isValid (A, B, 1));

    
}

/* Subtract two extensible sparse matrices */
void esmat_sub (Esmat A, Esmat B, Esmat dest) {
    
    assert (esmat_isValid (A, B, 1));

}

/* Frobenius norm of one extensible sparse matrices */
double esmat_fnorm (Esmat A) {
    
    double fnorm = 0.0;
    for (int i = 0; i < A.val.size(); i++) {
        fnorm += A.val[i].second * 2;
    }

    return fnorm;
}

/* scalar times a esmat */
void esmat_scalar_mult (double scalar, Esmat A, Esmat dest) {

    assert (esmat_isValid (A, dest, 1));

    for (int i = 0; i < A.val.size(); i ++) {
        dest.val[i].second = scalar * A.val[i].second; 
    }

}

/* Check validity (dim alignment) of input esmat 
 *  mode:
 *    1 - same dim alignment
 *    2 - product alignment
 * */
esmat_isValid (Esmat A, Esmat B, int mode) {

    bool success = false;

    if (mode == 1) {
        if (A.nRows == B.nRows && A.nCols == B.nCols) 
            success = true;
    } else if (mode == 2) {
        if (A.nCols == B.nRows) 
            success = true;
    }

    return success;
}

/* frobenius product */
esmat_fdot (Esmat A, Esmat B) {

    assert (esmat_isValid (A, B, 1));

    int i = 0, j = 0;
    int indexA, indexB;
    int sizeA = A.val.size();
    int sizeB = B.val.size();
    double result = 0.0;

    while (i < sizeA && j < sizeB) {
        indexA = A.val[i].first;
        indexB = B.val[i].first;

        if (indexA < indexB) {
            ++ i; 
        } else if (indexA > indexB) {
            ++ j;
        } else { // equality
            result += A.val[i].second * B.val[j].second;
            ++i; ++j;
        }
    }

    return result;
}

void mat_sum_row (double ** src, double * dest, int nRows, int nCols) {
    
    for (int i = 0; i < nRows; i ++) {
        double sum = 0.0;
        for (int j = 0; j < nCols; j ++) {
            sum += src[i][j];
        }
        dest[i] = sum;
    }

}

void mat_sum_col(double ** src, double * dest, int nRows, int nCols) {
    
    for (int j = 0;j < nCols; j ++)
	    dest[j] = 0.0;

    for (int i = 0; i < nRows; i ++) {
        for (int j = 0; j < nCols; j ++) {
            dest[j] += src[i][j];
        }
    }
}

void mat_toString (double ** src, int nRows, int nCols) {

    string field_seperator = ",";
    string line_separator = "\n";
    for (int i = 0; i < nRows; i ++) {
        for (int j = 0; j < nCols; j ++) { 
            cout << src[i][j] << field_seperator;
        }
        cout << line_separator;
    }

}

void mat_copy (double ** src, double ** dest, int nRows, int nCols) {

    for (int i = 0; i < nRows; i ++) {
        for (int j = 0; j < nCols; j ++) {
            dest[i][j] = src[i][j];
        }
    }
}

/* regularization for penalizing global topics */
void mat_max_col (double ** src, double ** dest, int nRows, int nCols) {

    // we assume that the given dest is all-zero mat
    for (int j = 0; j < nCols; j ++) {
        int max_index = -1;
        double max_value = -INF;
        for (int i = 0; i < nRows; i ++) {
            if (src[i][j] > max_value) {
                max_index = i;
                max_value = src[i][j];
            }
	    dest[i][j] = 0;
        }
        dest[max_index][j] = 1;
    }
}

/* regularization for penalizing local topics */
mat_count_row () {


}

/* regularization for penalizing number of vocabularies used by topics */
mat_nonzero_index_col {

}

void mat_min_row (double ** src, double ** dest, int nRows, int nCols) {

    for (int i = 0; i < nRows; i ++) {
        int min_index = -1;
        double min_value = INF;
        for (int j = 0; j < nCols; j ++) {
            if (src[i][j] < min_value) {
                min_index = j;
                min_value = src[i][j];
            }
            dest[i][j] = 0;
        }
        assert (min_index >= 0);
        dest[i][min_index] = 1;
    }

}

void trim (double** mat, int R, int C) {
	
	for (int i = 0; i < R; i++) {
		for (int j = 0; j < C; j++) {
			if( fabs(mat[i][j]) < 1e-5 )
				mat[i][j] = 0.0;
		}
	}

}
