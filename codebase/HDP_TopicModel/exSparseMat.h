/*###############################################################
## MODULE: exSparseMat.h
## VERSION: 2.0 
## SINCE: 2014-07-24
## AUTHOR: Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
## DESCRIPTION: 
##     Header file for Extensible Sparse matrix  
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include<string>
#include<vector>
#include<fstream>
#include<cassert>
#include <algorithm>
#include"math.h"
using namespace std;

/* Global variables */
const double DUMMY_PENALTY_RATE = 1000.0;
const double TRIM_THRESHOLD = 10e-5;

/* Definition of Data structure for Extensible Sparse Matrix (Esmat*) */
typedef struct {
    int nRows; int nCols;
    vector< pair<int, double> >  val;
} Esmat ;

typedef double (* Operation) (double, double); 

/* Prototype for fundamental functions, typically computational frameworks*/
double esmat_unary_operate (Esmat *A, Operation opt);
void esmat_bin_operate (Esmat* A, Esmat* B, Esmat* dest, Operation opt);
void esmat_operate_col (Esmat* A, Esmat* dest, Operation opt, double init_value);
void esmat_operate_row (Esmat* A, Esmat* dest, Operation opt, double init_value);

/* Allocation and De-allocation */
Esmat* esmat_init (int nRows, int nCols);
Esmat* esmat_init (Esmat * A);
Esmat* esmat_init ();
void esmat_init_all (vector<Esmat*>* src);
Esmat* esmat_read (string fname);
bool esmat_equal (Esmat* esmat, double **mat);
void esmat_free (Esmat* src);
void esmat_free_all (vector<Esmat*> src);
void esmat_zeros (Esmat* A);

/* Rearrange one esmat */
void esmat_align (Esmat* mat);
void esmat_copy (Esmat* A, Esmat* D);
void esmat_trim (Esmat* A);

/* submat and merge */
void esmat_submat_row (Esmat* mat, vector<Esmat*> submats, vector< pair<int,int> >* look_up);
void esmat_submat_row (Esmat* mat, vector<Esmat*> submats, vector<int>* word_lookup, vector< vector<int> >* voc_lookup);
void esmat_merge_row (Esmat* submat, int start_index, int end_index, Esmat* mat);
void esmat_merge_row (Esmat* submat, vector<int>* sub_voc_lookup, Esmat* mat);

/* frobenius product and norm */
void esmat_abs (Esmat* A, Esmat* dest);
double esmat_fdot (Esmat* A, Esmat* B);
double esmat_sum (Esmat* A);
double esmat_fnorm (Esmat* A);

/* scalar multiplication */
void esmat_scalar_mult (double scalar, Esmat* A);
void esmat_scalar_mult (double scalar, Esmat* A, Esmat* dest);

/* Auxiliary functions */
bool esmat_isValid (Esmat* A, Esmat* B, int mode);
string esmat_toString (Esmat* A);

/* Compute dummy term */
double esmat_compute_dummy (Esmat* A);

/* Add and Subtract two extensible sparse matrices */
void esmat_add (Esmat* A, Esmat* B, Esmat* dest);
void esmat_sub (Esmat* A, Esmat* B, Esmat* dest);

/* min, max and sum over column and row elements */
void esmat_min_col (Esmat* A, Esmat* dest);
void esmat_max_col (Esmat* A, Esmat* dest);
void esmat_sum_col (Esmat* A, Esmat* dest);
void esmat_min_row (Esmat* A, Esmat* dest);
void esmat_max_row (Esmat* A, Esmat* dest);
void esmat_sum_row (Esmat* A, Esmat* dest); 
