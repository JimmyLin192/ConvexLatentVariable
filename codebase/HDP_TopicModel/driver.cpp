/*###############################################################
## MODULE: driver.cpp
## VERSION: 1.0 
## SINCE 2014-07-26
## AUTHOR Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
## DESCRIPTION: 
##      
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include "exSparseMat.h"
#include "HDP.h"
#include <string>
#include <vector>

// entry main function
int main (int argc, char ** argv) {

    // EXCEPTION control: illustrate the usage if get input of wrong format
    if (argc < 5) {
        cerr << "Usage: HDP [voc_dataFile] [doc_dataFile] [lambda_global] [lambda_local] [lambda_coverage]" << endl;
        exit(-1);
    }

    // PARSE arguments
    string voc_file (argv[1]);
    string doc_file (argv[2]);
    vector<double> LAMBDAs (3, 0.0);
    LAMBDAs[0] = atof(argv[3]); // lambda_document
    LAMBDAs[1] = atof(argv[4]); // lambda_topic
    LAMBDAs[2] = atof(argv[5]); // lambda_block

    // preprocess the input dataset
    Lookups lookup_tables;
    vector<string> voc_list();
    lookup_tables.doc_lookup = new vector< pair<int,int> >();
    lookup_tables.word_lookup = new vector<int>();
    lookup_tables.voc_lookup = new vector< vector<int> >();
    
    voc_list_read (voc_file, &voc_list);
    document_list_read (doc_file, &lookup_tables)
    
    int D = dimensions;
    cerr << "D = " << D << endl; // # features
    cerr << "N = " << N << endl; // # instances
    cerr << "lambda_global = " << LAMBDAs[0] << endl;
    cerr << "lambda_local = " << LAMBDAs[1] << endl;
    cerr << "lambda_coverage = " << LAMBDAs[2] << endl;
    cerr << "TRIM_THRESHOLD = " << TRIM_THRESHOLD << endl;

    int seed = time(NULL);
    srand (seed);
    cerr << "seed = " << seed << endl;

    // restore matchness matrix in sparse representation
    /* here we consider non-noise version of topic model
    double ** match_mat = mat_init (N, N);
    mat_zeros (match_mat, N, N);
    */

    // Run sparse convex clustering
    Esmat* W = esmat_init (N, 1);
    HDP (D, N, LAMBDAs, W, lookup_tables);

    // Output results
    ofstream fout("result");

    // interpret result by means of voc_list
    /*{{{*/
    /*
    vector<int> centroids = get_all_centroids(W, N, N); // contains index of all centroids
    
    int nCentroids = centroids.size();
    for (int i = 0; i < N; i ++) {
        // output identification and its belonging
        fout << "id=" << i+1 << ", fea[0]=" << data[i]->fea[0].second << ", ";  // sample id
        for (int j = 0; j < N; j ++) {
            if( fabs(W[i][j]) > 3e-1 ) {
                fout << j+1 << "(" << W[i][j] << "),\t";
            }
        }
	fout << endl;

        // output distance of one sample to each centroid 
        fout << "dist_centroids: (";
        for (int j = 0; j < nCentroids - 1; j ++) {
            fout << dist_mat[i][ centroids[j] ] << ", ";
        }
        fout << dist_mat[i][ centroids[nCentroids-1] ] << ")";
        fout << endl;
    }
    */
/*}}}*/

    // free resources
    delete lookup_tables.doc_lookup;
    delete lookup_tables.word_lookup;
    delete lookup_tables.voc_lookup;
}
