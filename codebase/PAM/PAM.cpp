/*###############################################################
## MODULE: PAM.cpp
## VERSION: 1.0 ## SINCE 2014-06-14
## AUTHOR:
##     Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
## DESCRIPTION: 
##
################################################################# 
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include "PAM.h"
#include <cassert>
#include <cmath>
#define INTEGER_MAX 30000

typedef double (* dist_func) (Instance*, Instance*, int); 
double L2norm (Instance * ins1, Instance * ins2, int D) {
    // TODO: 
    //   1. refine by using hash table to restore each instance
    assert (ins1->fea.size() == D);
    assert (ins2->fea.size() == D);

    double * diff = new double [D];
    for (int i = 0; i < D; i ++) {
        diff[ ins1->fea[i].first-1 ] = ins1->fea[i].second;
    }
    for (int i = 0; i < D; i ++) {
        diff[ ins2->fea[i].first-1 ] -= ins2->fea[i].second;
    }

    double norm = 0.0;
    for (int i = 0; i < D; i ++) {
        norm += diff[i] * diff[i];
    }
	
    delete[] diff;
    return norm;
}
/* Compute the mutual distance of input instances contained within "data" */
void compute_dist_mat (vector<Instance*>& data, double ** dist_mat, int N, int D, dist_func df, bool isSym) {
    for (int i = 0; i < N; i ++) {
        for (int j = 0; j < N; j ++) {
            Instance * xi = data[i];
            Instance * muj = data[j];
            dist_mat[i][j] = df (xi, muj, D);
        }
    }
    for (int i = 0; i < N; i ++) {
        for (int j = 0; j < N; j ++) {
            if (j == i) {
                assert (dist_mat[i][j] == 0);
            } else {
                assert (dist_mat[i][j] == dist_mat[j][i]);
            }
        }
    }
}

void PAM (double** dist_mat, int N, int K, double** W, int* medoids) {
    // STEP ZERO: validate input
    for (int i = 0; i < N; i ++) {
        for (int j = 0; j < N; j++) {
            assert (dist_mat[i][j]>=0.0);
        }
    }
    vector<int> last_medoids (K, 0);
    vector<int> new_medoids (K, 0);
    // STEP ONE: a. randomly pick up initial K medoid
    // NOTE THAT this sampling method assumes that K << N
    int* pool = new int[N];
    for (int i = 0; i < N; i++) pool[i] = i;
    for (int j = 0; j < K; j++) {
        int rand = random() % (N-j); // generate random number from [0,n-1]
        // cout << "rand: " << rand << endl;
        int index = N-1-j; // get index of last available slot
        int temp = pool[index]; // get value of last available slot
        // swap position
        pool[index] = pool[rand]; 
        pool[rand] = temp;
        // assign generated random value to new_medoids[]
        new_medoids[j] = pool[index];
    }
    delete[] pool; // remove pool (temporary)
    cout << "randomized medoids: ";
    for (int i = 0; i < K; i++) {
        cout << new_medoids[i] << ",";
    }
    cout << endl;

    // OPTIONAL: write randomized medoids to stdout or external files
    
    double last_cost = INF, new_cost = INF;
    double ** temp = mat_init (N,N);
    double ** w = mat_init (N,N);
    while (true) {
        // STEP TWO: E-step, assign to closest medoid, get new w
        mat_set_all (temp, INF, N, N);
        for (int i = 0; i < K; i ++) {
            for (int j = 0; j < N; j ++) {
                temp[j][new_medoids[i]] = dist_mat[j][new_medoids[i]];
            }
        }
        mat_zeros (w, N, N);
        mat_min_row (temp, w, N, N);

        // STEP THREE: compute cost
        mat_zeros (temp, N, N);
        mat_times (w, dist_mat, temp, N, N); // temp = dist to closest medoid
        new_cost = mat_norm2 (temp, N, N);

        cout << "new_cost: " << new_cost << endl;
        // STEP FOUR: stopping criteria
        if (new_cost >= last_cost) {
              cout << "CLUSTERING COST: " << last_cost << endl;
              break;
        } // medoids has been the optimal
        else {
            for (int i = 0; i < K; i ++) {
                last_medoids[i] = new_medoids[i];
            }
            last_cost = new_cost;
        }

        // STEP FIVE: M-step choose new medoid by computing every sample 
        for (int i = 0; i < K; i ++) {
            vector<int> cluster_points;
            for (int j = 0; j < N; j ++) {
                if (w[j][last_medoids[i]] > 0) 
                    cluster_points.push_back(j);
            }
            int nPoints = cluster_points.size();
            double ** cluster_dist_mat = mat_init(nPoints, nPoints);
            for (int p = 0; p < nPoints; p ++) {
                for (int q = 0; q < nPoints; q ++) {
                    cluster_dist_mat[p][q] = 
                        dist_mat[cluster_points[p]][cluster_points[q]];
                }
            }
            double* squared_dist = new double [nPoints];
            mat_sum_col(cluster_dist_mat, squared_dist, nPoints, nPoints);
            int min_index = INTEGER_MAX;
            double min_value = INF;
            for (int j = 0; j < nPoints; j++) {
                if (squared_dist[j] < min_value) {
                    min_index = j;
                    min_value = squared_dist[j];
                }
            }
            assert (min_index < nPoints);
            new_medoids[i] = cluster_points[min_index];
            delete [] squared_dist;
            mat_free (cluster_dist_mat, nPoints, nPoints);
        }
    }

    // STEP SEVEN: put converged solution to destination W
    mat_copy (w, W, N, N);
    for (int i = 0; i < K; i ++) {
        medoids[i] = last_medoids[i];
    }
    // STEP EIGHT: memory recollection
    mat_free (temp, N, N);
    mat_free (w, N, N);
}

// entry main function
int main (int argc, char ** argv) {

    // exception control: illustrate the usage if get input of wrong format
    if (argc < 4) {
        cerr << "Usage: PAM [dataFile] [FIX_DIM] [K]" << endl;
        cerr << "Note: dataFile must be scaled to [0,1] in advance." << endl;
        exit(-1);
    }

    // parse arguments
    char* dataFile = argv[1];
    int FIX_DIM = atoi(argv[2]);
    int K = atoi(argv[3]);

    // read in data
    vector<Instance*> data;
    //read2D (dataFile, data);
    readFixDim (dataFile, data, FIX_DIM);

    // explore the data 
    int D = -1;
    int N = data.size(); // data size
    for (int i = 0; i < N; i++) {
        vector< pair<int,double> > * f = &(data[i]->fea);
        int last_index = f->size() - 1;
        if (f->at(last_index).first > D) {
            D = f->at(last_index).first;
        }
    }

    cerr << "D = " << D << endl; // # features
    cerr << "N = " << N << endl; // # instances
    cerr << "K = " << K << endl;
    int seed = time(NULL);
    srand (seed);
    cerr << "seed = " << seed << endl;

    // pre-compute distance matrix
    dist_func df = L2norm;
    double ** dist_mat = mat_init (N, N);
    mat_zeros (dist_mat, N, N);
    compute_dist_mat (data, dist_mat, N, D, df, true); 
    // Run sparse convex clustering
    double ** W = mat_init (N, N);
    mat_zeros (W, N, N);
    int* medoids = new int [K];
    // INVOKE algorithm function
    PAM (dist_mat, N, K, W, medoids);
    // Output results
    ofstream fout("result");

    for (int i = 0; i < K; i ++) {
        cout << "medoids[i] = " <<  medoids[i] << endl;
    }
    for (int i = 0; i < N; i ++) {
        // output identification and its belonging
        fout << "id=" << i+1 << ", fea[0]=" << data[i]->fea[0].second << ", ";  // sample id
        for (int j = 0; j < N; j ++) {
            if( fabs(W[i][j]) > 3e-1 ) {
                fout << j+1 << "(" << W[i][j] << "),\t";
            }
        }
        fout << endl;
        // output distance of one sample to each centroid 
        /*
           out << "dist_centroids: (";
           for (int j = 0; j < nCentroids - 1; j ++) {
           fout << dist_mat[i][ centroids[j] ] << ", ";
           }
           fout << dist_mat[i][ centroids[nCentroids-1] ] << ")";

           fout << endl;
           */
    }
    delete[] medoids;
    mat_free (W, N, N);
}
