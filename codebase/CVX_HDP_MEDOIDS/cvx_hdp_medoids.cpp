/*###############################################################
## MODULE: cvx_hdp_medoids.cpp
## VERSION: 2.0 
## SINCE 2014-07-21
## AUTHOR:
##     Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
##
## DESCRIPTION: 
##     Convex relaxation for cvx_hdp_medoids resolution
################################################################# 
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

/*
TODO list:
  1. compute_dist_mat generates matrix with N by D
  2. fixup bugs in frank_wolfe_solver 
  3. fixup problem in group_lasso_solver
  4. fixup local problem separation
*/

#include "cvx_hdp_medoids.h"

/* algorithmic options */ 
#define EXACT_LINE_SEARCH  // comment this to use inexact search

/* dumping options */
// #define FRANK_WOLFE_DEBUG
// #define EXACT_LINE_SEARCH_DUMP
// #define COVERAGE_SUBPROBLEM_DUMP
// #define LOCAL_SUBPROBLEM_DUMP
// #define GROUP_LASSO_DEBUG
// #define BLOCKWISE_DUMP
// #define NTOPIC_DUMP
#define SUBPROBLEM_DUMP

double sign (int input) {
    if (input > 0) return 1.0;
    else if ( input < 0 ) return -1.0;
    else return 0.0;
}
bool pair_Second_Elem_Comparator (const std::pair<int, double>& firstElem, const std::pair<int, double>& secondElem) {
    // sort pairs by second element with *decreasing order*
    return firstElem.second > secondElem.second;
}
/* Compute the mutual distance of input instances contained within "data" */
void compute_dist_mat (vector<Instance*>& data, double ** dist_mat, int N, int D, Lookups* lookup_tables) {
    // STEP ONE: compute distribution for each document
    vector< map<int, double> > distributions (D, map<int, double>());
    for (int i = 0; i < D; i ++) {
        // a. compute sum of word frequency
        int sumFreq = 0;
        Instance* xi = data[i];
        int n = xi->fea.size();
        for (int j = 0; j < n; j ++) {
            if (ins1->fea[i].first-1 < 0) continue;
            sumFreq += xi->fea[j].second;
        }
        // b. compute distribution
        for (int j = 0; j < n; j ++) {
            if (ins1->fea[i].first-1 < 0) continue;
            int index = ins1->fea[i].first;
            double value = 1.0 * xi->fea[j].second / sumFreq;
            distributions[i].insert(pair<int, double> (index, value));
        }
    }
    // STEP TWO: compute weight of word within one document
    for (int i = 0; i < N; i ++) {
        for (int j = 0; j < D; j ++) {
            int voc_index = lookup_tables->word_lookup[i];
            // KL-divergence distance:
            //   =  P(i) ln( P(i)/Q(i) )
            // TODO:
            dist_mat[i][j] = -log(distributions[j][voc_index]/ );
        }
    }
}
/* dummy_penalty = r dot (1 - sum_k w_nk) */
double get_dummy_loss (Esmat* Z) {
    Esmat* temp_vec = esmat_init (Z->nRows, 1);
    esmat_sum_row (Z, temp_vec);
    double dummy_loss = esmat_compute_dummy (temp_vec);
    esmat_free (temp_vec);
    return dummy_loss;
}
/* \lambda_g \sumk \maxn |\wnk| */
double get_global_topic_reg (Esmat* absZ, double lambda) {
    if (absZ->val.size() == 0) {
        return 0.0;
    }
    Esmat* maxn = esmat_init (1, absZ->nCols);
    Esmat* sumk = esmat_init (1, 1);
    esmat_max_over_col (absZ, maxn);
    esmat_sum_row (maxn, sumk);
    double global_topic_reg = -INF;
    if (sumk->val.size() > 0)
        global_topic_reg = lambda * sumk->val[0].second; 
    else 
        global_topic_reg = 0.0;
    esmat_free (sumk);
    esmat_free (maxn);
    return global_topic_reg;
}
/* \lambdal \sum_d \sum_k \underset{n \in d}{\text{max}} |\wnk| */
double get_local_topic_reg (Esmat* absZ, double lambda, vector< pair<int,int> >* doc_lookup) {
    // STEP ONE: initialize sub matrix for each document
    int nDocs = doc_lookup->size();
    vector<Esmat*> sub_absZ (nDocs);
    for (int d = 0; d < nDocs; d ++) {
        sub_absZ[d] = esmat_init (0,0);
    }

    // STEP TWO: separate entire Z to submat Z
    esmat_submat_row (absZ, sub_absZ, doc_lookup);

    // STEP THREE: compute global topic regularizer for each localized doc
    double local_topic_reg = 0.0;
    for (int d = 0; d < nDocs; d ++) {
        // cout << "size[" << d << "]: " << sub_absZ[d]->val.size() << endl;
        local_topic_reg += get_global_topic_reg (sub_absZ[d], lambda); 
    }

    // Final: free resource
    esmat_free_all (sub_absZ);
    return local_topic_reg;
}
double subproblem_objective (int prob_index, Esmat* Y, Esmat* Z, Esmat* W, double RHO, double lambda, Lookups* tables) {
    string title = "";
    vector< pair<int,int> >* doc_lookup = tables->doc_lookup;
    vector<int>* word_lookup = tables->word_lookup; 
    vector< vector<int> >* voc_lookup = tables->voc_lookup;
    /*
       cout << "[W" << prob_index << "]"<< endl;
       cout << esmat_toInfo(W);
       cout << esmat_toString (W);
       cout << "[Y" << prob_index << "]"<< endl;
       cout << esmat_toInfo(Y);
       cout << esmat_toString (Y);
       cout << "[Z" << prob_index << "]"<< endl;
       cout << esmat_toInfo(Z);
       cout << esmat_toString (Z);
       */

    // STEP ONE: compute main term
    double main = -1.0;
    if (prob_index == 1) {
        title = "Dummy_Loss";
        // cout << "begin to compute dummy loss" << endl;
        // dummy_penalty = r dot (1 - sum_k w_nk)
        main = get_dummy_loss (W);
    } else {
        Esmat* absW = esmat_init (W);
        esmat_abs (W, absW);
        if (prob_index == 2) {
            title = "Global_Reg";
            main = get_global_topic_reg (absW, lambda);
        } else if (prob_index == 3) {
            title = "Local_Reg";

            main = get_local_topic_reg (absW, lambda, doc_lookup);
        }/* else if (prob_index == 4) {
            title = "Coverage_Reg";
            main = get_coverage_reg (absW, lambda, word_lookup, voc_lookup);
        }*/
        esmat_free (absW);
    }
    Esmat* w_minus_z = esmat_init ();
    // STEP TWO: compute linear term: linear = y^T dot (w - z) 
    esmat_sub (W, Z, w_minus_z); // temp = w - z
    double linear = esmat_fdot (Y, w_minus_z);
    // STEP THREE: compute quadratic term: quadratic = 0.5 * RHO * || w - z ||^2 
    double quadratic = 0.5 * RHO * esmat_fnorm (w_minus_z);
    double total = main + linear + quadratic;
    esmat_free (w_minus_z);
#ifdef SUBPROBLEM_DUMP
    cout << title << ": " << main << ", ";
    cout << "linear: " << linear << ", ";
    cout << "quadratic: " << quadratic << ", ";
    cout << "total: " << total << endl;
#endif
    return total;
}
double original_objective (Esmat* Z, vector<double> LAMBDAs, Lookups* tables) {
    vector< pair<int,int> >* doc_lookup = tables->doc_lookup;
    vector<int>* word_lookup = tables->word_lookup; 
    vector< vector<int> >* voc_lookup = tables->voc_lookup;

    Esmat* absZ = esmat_init (Z);
    esmat_abs (Z, absZ);
    // STEP ONE: compute dummy loss
    double dummy = get_dummy_loss (Z);
    // cout << "dummy =" << dummy << endl;

    // STEP TWO: compute "GLOBAL TOPIC" group-lasso regularization
    double global_topic_reg = get_global_topic_reg (absZ, LAMBDAs[0]);
    esmat_free (absZ); 
    return dummy + global_topic_reg;
}
void frank_wolfe_solver (double** dist_mat, Esmat * Y_1, Esmat * Z_1, Esmat * w_1, double RHO) {

    bool is_global_optimal_reached = false;

    // cout << "within frank_wolfe_solver" << endl;
    // This can be computed by using corner point. 
    Esmat * gradient = esmat_init (w_1);
    Esmat * s = esmat_init (w_1);

#ifndef EXACT_LINE_SEARCH
    int K = 300;
#else
    int K = 10;
    Esmat * w_minus_s = esmat_init ();
    Esmat * w_minus_z = esmat_init ();
#endif

    int k = 0; // iteration number
    double gamma; // step size
    double penalty;
    Esmat * tempS = esmat_init (w_1);

    //esmat_zeros (w_1);
    double sum1, sum2, sum3, sum4;
    // cout << "within frank_wolfe_solver: start iteration" << endl;
    while (k < K && !is_global_optimal_reached) {
        // STEP ONE: find s that minimizes <s, grad f>
        // gradient[i][j] = dist_mat[i][j] +  Y_1[i][j] + RHO * (w_1[i][j] - Z_1[i][j]) ;  //- r[i];
        esmat_sub (w_1, Z_1, tempS);
        esmat_scalar_mult (RHO, tempS);
        esmat_add (Y_1, tempS, gradient);
        esmat_copy (gradient, tempS);
        esmat_add (tempS, dist_mat, gradient);
        esmat_min_row (gradient, s);
#ifdef FRANK_WOLFE_DEBUG
        cout << "=============================" << endl;
        cout << "[w_1]" << endl;
        cout << w_1->nRows << "," << w_1->nCols << "," << w_1->val.size() << endl;
        cout << esmat_toString(w_1);

        cout << "[gradient]" << endl;
        cout << gradient->nRows << "," << gradient->nCols << "," << gradient->val.size() << endl;
        cout << esmat_toString(gradient);
        cout << endl;
        cout << "[s]" << endl;
        cout << s->nRows << "," << s->nCols << "," << s->val.size() << endl;
        cout << esmat_toString(s);
#endif 
        // cout << "within frank_wolfe_solver: step one finished" << endl;

        // STEP TWO: apply exact or inexact line search to find solution
#ifndef EXACT_LINE_SEARCH
        // Here we use inexact line search
        gamma = 2.0 / (k + 2.0);
#else
        // Here we use exact line search 
        if (k == 0) {
            gamma = 1.0;
        } else {
        // gamma* = (sum1 + sum2 + sum3) / sum4, where
        // sum1 = 1/2 sum_n sum_k (w - s)_nk * || x_n - mu_k ||^2
        // sum2 = sum_n sum_k (w - s)_nk
        // sum3 = - RHO * sum_n sum_k  (w - z) 
        // sum4 = sum_n sum_k RHO * (s - w)
        esmat_sub (w_1, s, w_minus_s);
        // cout << esmat_toString(w_minus_s);
        esmat_sub (w_1, Z_1, w_minus_z);

        // NOTE: in case of ||w_1 - s||^2 = 0, not need to optimize anymore
        // since incremental term = w + gamma (s - w), and whatever gamma is,
        // w^(k+1) = w^(k), this would be equivalent to gamma = 0
        if (esmat_fnorm(w_minus_s) == 0) {
            gamma = 0;
            is_global_optimal_reached = true;
            // reach the exit condition, do not make more iteration
        } else {
            /*
            esmat_fdot (w_minus_s, dist_mat, tempS);
            sum1 = 0.5 * esmat_sum (tempS);
            */
#ifdef EXACT_LINE_SEARCH_DUMP
            cout << "[w_minus_s]" << endl;
            cout << esmat_toString(w_minus_s);
            cout << "[w_minus_z]" << endl;
            cout << esmat_toString(w_minus_z);
#endif
            sum2 = esmat_fdot (Y_1, w_minus_s);
            sum3 = RHO * esmat_fdot (w_minus_z, w_minus_s);
            sum4 = RHO * esmat_fnorm (w_minus_s);
            // gamma should be within interval [0,1]
            // gamma = (sum1 + sum2 + sum3) / sum4;
            gamma = (sum2 + sum3) / sum4;

#ifdef EXACT_LINE_SEARCH_DUMP
            cout << "[exact line search] (sum2, sum3, sum4, gamma) = ("
                << sum2 << ", " << sum3 << ", " << sum4 << ", " << gamma
                << ")"
                << endl;
#endif
        }

        }
#endif
        // update the w^(k+1)
        esmat_scalar_mult (gamma, s); 
        /*
        cout << "[gamma*s]" << endl;
        cout << esmat_toString(s);
        */
        esmat_scalar_mult (1.0-gamma, w_1);
        esmat_copy (w_1, tempS);
        esmat_add (tempS, s, w_1);
        /*
        cout << "[post w_1]" << endl;
        cout << esmat_toString(w_1);
        */

        // cout << "within frank_wolfe_solver: step three finished" << endl;
        // report the #iter and objective function
        /*
           cout << "[Frank-Wolfe] iteration: " << k << ", first_subpro_obj: " << penalty << endl;
        */

        k ++;
    // cout << "within frank_wolfe_solver: next iteration" << endl;
    }
    // cout << "within frank_wolfe_solver: to free gradient" << endl;
    esmat_free (gradient);
    // cout << "within frank_wolfe_solver: to free temps" << endl;
    esmat_free (tempS);
    // cout << "within frank_wolfe_solver: to free s " << endl;
    esmat_free (s);
    // cout << "end frank_wolfe_solver: finished! " << endl;
}
void group_lasso_solver (Esmat* Y, Esmat* Z, Esmat* w, double RHO, double lambda) {
    // STEP ONE: compute the optimal solution for truncated problem
    Esmat* wbar = esmat_init (Z);
    Esmat* temp = esmat_init (Z);
    esmat_scalar_mult (RHO, Z, temp); // wbar = RHO * z
    // cout << wbar->nRows << "," << wbar->nCols << endl;
    // cout << Y->nRows << "," << Y->nCols << endl;
    esmat_sub (temp, Y, wbar); // wbar = RHO * z - y
    esmat_scalar_mult (1.0/RHO, wbar); // wbar = (RHO * z - y) / RHO
    esmat_free (temp);
#ifdef GROUP_LASSO_DEBUG
    cout << "[wbar]" << endl;
    cout << esmat_toString(wbar);
    cout << "lambda: " << lambda << endl;
#endif
    // STEP TWO: find the closed-form solution for second subproblem
    int SIZE = wbar->val.size();
    int R = wbar->nRows; int C = wbar->nCols;

    if (wbar->val.size() == 0) {
        // no need to solve all-zero matrix w
        return ;
    }
    
    // i is index of element in esmat->val, j is column index
    int i = 0; int j = 0;
    int begin_idx, end_idx;
    int col_es_begin = wbar->val[0].first;
    vector< pair<int,double> > alpha_vec;
    while (i < SIZE && j < C) {
        begin_idx = j * R;
        end_idx = (j+1) * R;
        int esWBAR_index = wbar->val[i].first;
        if (esWBAR_index >= end_idx) { 
            // a) sort existing temp_vec
            std::sort (alpha_vec.begin(), alpha_vec.end(), pair_Second_Elem_Comparator);
            // b) find mstar
            int mstar = 0; // number of elements supporting the sky
            double separator;
            double max_term = -INF, new_term;
            double sum_alpha = 0.0;
            int nValidAlpha = alpha_vec.size();
            for (int v = 0; v < nValidAlpha; v ++) {
                sum_alpha += alpha_vec[v].second;
                new_term = (sum_alpha - lambda) / (v + 1.0);
               // cout << "new_term: " << new_term << endl;
                if ( new_term > max_term ) {
                    separator = alpha_vec[v].second;
                    max_term = new_term;
                    ++ mstar;
                }
            }
            // cout << "mstar: " << mstar << endl;
            // c) assign closed-form solution of current column to w
            if (nValidAlpha == 0 || mstar <= 0) {
                ; // this column of w is all-zero, hence we do nothing for that 
            } else {
                for (int esi = col_es_begin; wbar->val[esi].first < end_idx; esi ++) {
                    double pos = wbar->val[esi].first;
                    double value = wbar->val[esi].second;
                    if (fabs(value) >= separator) 
                        w->val.push_back(make_pair(pos, max(max_term, 0.0)));
                    else 
                        // w->val.push_back(make_pair(pos, max(value, 0.0)));
                        w->val.push_back(make_pair(pos, value));
                }
            }
            // d) clear all elements in alpha_vec 
            alpha_vec.clear();
            // e) push current element to the cleared alpha_vec
            double value = wbar->val[i].second;
            alpha_vec.push_back (make_pair(esWBAR_index % R, fabs(value)));
            // f) go to operate next element and next column
            col_es_begin = i;
            ++ i; ++ j;
        } else if (esWBAR_index >= begin_idx) {
            // a) push current element to the cleared temp_vec
            double value = wbar->val[i].second;
            alpha_vec.push_back (make_pair(esWBAR_index % R, fabs(value)));
            // b) go to operate next element with fixed column index (j)
            ++ i; 
        } else { // impossible to occur
            assert (false);
        }
    }
    if (alpha_vec.size() > 0) {
        // a) sort existing temp_vec
        std::sort (alpha_vec.begin(), alpha_vec.end(), pair_Second_Elem_Comparator);
        // b) find mstar
        int mstar = 0; // number of elements supporting the sky
        double separator;
        double max_term = -INF, new_term;
        double sum_alpha = 0.0;
        int nValidAlpha = alpha_vec.size();
        for (int v = 0; v < nValidAlpha; v ++) {
            sum_alpha += alpha_vec[v].second;
            new_term = (sum_alpha - lambda) / (v + 1.0);
            // cout << "new_term: " << new_term << endl;
            if ( new_term > max_term ) {
                separator = alpha_vec[v].second;
                max_term = new_term;
                ++ mstar;
            }
        }
            // cout << "mstar: " << mstar << endl;
        // c) assign closed-form solution of current column to w
        if (nValidAlpha == 0 || mstar <= 0) {
            ; // this column of w is all-zero, hence we do nothing for that 
        } else {
            for (int esi = col_es_begin; esi < SIZE; esi ++) {
                double pos = wbar->val[esi].first;
                double value = wbar->val[esi].second;
                if (fabs(value) >= separator) 
                    w->val.push_back(make_pair(pos, max(max_term, 0.0)));
                else 
                    // w->val.push_back(make_pair(pos, max(value, 0.0)));
                    w->val.push_back(make_pair(pos, value));
            }
        }
    }
#ifdef GROUP_LASSO_DEBUG
    cout << "[w]"  << esmat_toInfo (w) << endl;
    cout << esmat_toString (w);
#endif
    esmat_trim (w);
#ifdef GROUP_LASSO_DEBUG
    cout << "[w after trimming]"  << esmat_toInfo (w) << endl;
    cout << esmat_toString (w);
#endif
    // STEP THREE: recollect temporary variable - wbar
    esmat_free (wbar);
}

/* three subproblems that employed group_lasso_solver in different ways */
void global_topic_subproblem (Esmat* Y, Esmat* Z, Esmat* w, double RHO, double lambda) {
    group_lasso_solver (Y, Z, w, RHO, lambda);
}
void local_topic_subproblem (Esmat* Y, Esmat* Z, Esmat* w, double RHO, double lambda, Lookups* tables) {

    vector< pair<int,int> >* doc_lookup = tables->doc_lookup;
    vector<int>* word_lookup = tables->word_lookup; 
    vector< vector<int> >* voc_lookup = tables->voc_lookup;

#ifdef LOCAL_SUBPROBLEM_DUMP
    cout << "[local w input]" << w->nRows << "," << w->nCols << "," << w->val.size() << endl;
    esmat_toString (w);
#endif

    int nDocs = tables->nDocs;
    Esmat* tempW = esmat_init (w);
    vector<Esmat*> subW (nDocs); 
    vector<Esmat*> subY (nDocs);
    vector<Esmat*> subZ (nDocs);
    // STEP ZERO: initialize all submats
    for (int d = 0; d < nDocs; d ++) {
        subW[d] = esmat_init (0,0);
        subY[d] = esmat_init (0,0);
        subZ[d] = esmat_init (0,0);
    }
    // STEP ONE: separate esmat Y, Z, w to multiple small-sized esmat
    // NOTE: all esmat position has to be recomputed
    esmat_submat_row (w, subW, doc_lookup);
    esmat_submat_row (Y, subY, doc_lookup);
    esmat_submat_row (Z, subZ, doc_lookup);

    for (int d = 0; d < nDocs; d ++) {
#ifdef LOCAL_SUBPROBLEM_DUMP
        cout << "subW[d" << d << "]" << esmat_toInfo(subW[d]);
        cout << "subY[d" << d << "]" << esmat_toInfo(subY[d]);
        cout << esmat_toString(subY[d]);
        cout << "subZ[d" << d << "]" << esmat_toInfo(subZ[d]);
        cout << esmat_toString(subZ[d]);
#endif
        // STEP TWO: invoke group_lasso_solver to each individual group
        group_lasso_solver (subY[d], subZ[d], subW[d], RHO, lambda);

#ifdef LOCAL_SUBPROBLEM_DUMP
        cout << "res_subW[d" << d << "]" << esmat_toInfo(subW[d]);
#endif

        // STEP TREE: merge solution of each individual group (place back)
        // NOTE: all esmat position has to be recomputed
        int start_row = (*doc_lookup)[d].first;
        int end_row = (*doc_lookup)[d].second;
        esmat_merge_row (subW[d], start_row, end_row, tempW);
    }
    // realign the mat->val with index-increasing order
    esmat_align (tempW);
    // STEP FIVE: free auxiliary resource
    for (int d = 0; d < nDocs; d ++) {
        esmat_free (subW[d]);
        esmat_free (subY[d]);
        esmat_free (subZ[d]);
    }
#ifdef LOCAL_SUBPROBLEM_DUMP
    cout << "[local w before output]" << w->nRows << "," << w->nCols << "," << w->val.size() << endl;
    cout << "[tempW] " << esmat_toInfo(tempW);
#endif

    // FINAL: update merged solution to w
    esmat_copy (tempW, w);

#ifdef LOCAL_SUBPROBLEM_DUMP
    cout << "[local w output]" << w->nRows << "," << w->nCols << "," << w->val.size() << endl;
#endif
}
void cvx_hdp_medoids (double** dist_mat, vector<double> LAMBDAs, Esmat* W, Lookups* tables) {
    // SET MODEL-RELEVANT PARAMETERS 
    assert (LAMBDAs.size() == 2);
    double ALPHA = 1.0;
    double RHO = 1.0;
    int N = tables->nWords;
    int D = tables->nDocs;

    /* DECLARE AND INITIALIZE INVOLVED VARIABLES AND MATRICES */
    Esmat* w_1 = esmat_init (N, D);
    Esmat* w_2 = esmat_init (N, D);
    Esmat* w_3 = esmat_init (N, D);

    Esmat* y_1 = esmat_init (N, D);
    Esmat* y_2 = esmat_init (N, D);
    Esmat* y_3 = esmat_init (N, D);

    Esmat* z = esmat_init (N, D);

    Esmat* diff_1 = esmat_init (N, D);
    Esmat* diff_2 = esmat_init (N, D);
    Esmat* diff_3 = esmat_init (N, D);

    /* SET ITERATION-RELEVANT VARIABLES */
    double error = INF;
    int iter = 0; 
    int max_iter = 2000;

    /* ITERATIVE OPTIMIZATION */
    while ( iter < max_iter ) { // STOPPING CRITERIA
        // STEP ZERO: RESET ALL SUBPROBLEM SOLUTIONS (OPTIONAL) 
        esmat_zeros (w_1);
        esmat_zeros (w_2);
        esmat_zeros (w_3);
       
        // STEP ONE: RESOLVE W_1, W_2, W_3, W_4
        // resolve w_1
        // cout << "[w_1 before frank_wolfe_solver] " << esmat_toInfo(w_1);
        // cout << esmat_toString (w_1);
        frank_wolfe_solver (dist_mat, y_1, z, w_1, RHO); 
        double sub1_obj = subproblem_objective (1, y_1, z, w_1, RHO, 0.0, tables);
        // cout << "[w_1 after frank_wolfe_solver]" << esmat_toInfo(w_1);
        // out << esmat_toString (w_1);
        
        // resolve w_2
        global_topic_subproblem (y_2, z, w_2, RHO, LAMBDAs[0]);
        // compute value of objective function
        double sub2_obj = subproblem_objective (2, y_2, z, w_2, RHO, LAMBDAs[0],tables);
        // cout << "sub2_objective: " << sub2_obj << endl;

        // cout << "[w_3]" << w_3->nRows << "," << w_3->nCols << "," << w_3->val.size() << endl;
        local_topic_subproblem (y_3, z, w_3, RHO, LAMBDAs[1], tables);
        // cout << "[w_3]" << w_3->nRows << "," << w_3->nCols << "," << w_3->val.size() << endl;
        double sub3_obj = subproblem_objective (3, y_3, z, w_3, RHO, LAMBDAs[1], tables);

        // STEP TWO: update z by averaging w_1, w_2 and w_4
        Esmat* temp = esmat_init (N, D);
        esmat_add (w_1, w_2, z);
        esmat_copy (z, temp);
        esmat_add (temp, w_3, z);
        esmat_scalar_mult (1.0/3.0, z);

        cout << "[z]" << endl;
        cout << esmat_toString (z);

        // STEP THREE: update the y_1 and y_2 by w_1, w_2 and z
        esmat_sub (w_1, z, diff_1);
        esmat_scalar_mult (ALPHA, diff_1);
        esmat_copy (y_1, temp);
        esmat_add (temp, diff_1, y_1);

        esmat_sub (w_2, z, diff_2);
        esmat_scalar_mult (ALPHA, diff_2);
        esmat_copy (y_2, temp);
        esmat_add (temp, diff_2, y_2);

        esmat_sub (w_3, z, diff_3);
        esmat_scalar_mult (ALPHA, diff_3);
        esmat_copy (y_3, temp);
        esmat_add (temp, diff_3, y_3);

        // double trace_wone_minus_z = esmat_fnorm (diff_1); 
        // double trace_wtwo_minus_z = esmat_fnorm (diff_2); 
        // double trace_wtwo_minus_z = esmat_fnorm (diff_3); 
        // double trace_wfour_minus_z = esmat_fnorm (diff_4); 
        
        cout << "[y_1]" << endl;
        cout << esmat_toString (y_1);
        cout << "[y_2]" << endl;
        cout << esmat_toString (y_2);
        cout << "[y_3]" << endl;
        cout << esmat_toString (y_3);

        // STEP FOUR: trace the objective function
        iter ++;
        cout << endl;
        cout << "###################[iter:"<<iter<<"]#####################" << endl;
       // if (iter == 2) return;
    }
    
    // STEP FIVE: memory recollection
    esmat_free (w_1);
    esmat_free (w_2);
    esmat_free (w_3);

    esmat_free (y_1);
    esmat_free (y_2);
    esmat_free (y_3);

    esmat_free (diff_1);
    esmat_free (diff_2);
    esmat_free (diff_3);

    // STEP SIX: put converged solution to destinated W
    esmat_copy (z, W);
    esmat_free (z);
}

// entry main function
int main (int argc, char ** argv) {

    // EXCEPTION control: illustrate the usage if get input of wrong format
    if (argc < 5) {
        cerr << "Usage: " << endl;
        cerr << "\tcvx_hdp_medoids [voc_dataFile] [doc_dataFile] [lambda_global] [lambda_local]" << endl;
        exit(-1);
    }

    // PARSE arguments
    string voc_file (argv[1]);
    string doc_file (argv[2]);
    vector<double> LAMBDAs (2, 0.0);
    LAMBDAs[0] = atof(argv[3]); // lambda_document
    LAMBDAs[1] = atof(argv[4]); // lambda_topic

    // preprocess the input dataset
    vector<string> voc_list;
    voc_list_read (voc_file, &voc_list);
    int nVocs = voc_list.size();

    vector< pair<int,int> > doc_lookup;
    vector<int> word_lookup;
    vector< vector<int> > voc_lookup (nVocs, vector<int>());
    Lookups lookup_tables;
    lookup_tables.doc_lookup = &doc_lookup;
    lookup_tables.word_lookup = &word_lookup;
    lookup_tables.voc_lookup = &voc_lookup;
    document_list_read (doc_file, &lookup_tables);
    
    lookup_tables.nDocs = lookup_tables.doc_lookup->size();
    lookup_tables.nWords = lookup_tables.word_lookup->size();
    lookup_tables.nVocs = nVocs;
    int seed = time(NULL);
    srand (seed);
    cerr << "###########################################" << endl;
    cerr << "nVocs = " << lookup_tables.nVocs << endl; // # vocabularies
    cerr << "nDocs = " << lookup_tables.nDocs << endl; // # documents
    cerr << "nWords = " << lookup_tables.nWords << endl; // # words
    cerr << "lambda_global = " << LAMBDAs[0] << endl;
    cerr << "lambda_coverage = " << LAMBDAs[1] << endl;
    cerr << "TRIM_THRESHOLD = " << TRIM_THRESHOLD << endl;
    cerr << "seed = " << seed << endl;
    cerr << "###########################################" << endl;

    // Run sparse convex clustering
    int N = lookup_tables.nWords;
    int D = lookup_tables.nDocs;
    Esmat* W = esmat_init (lookup_tables.nWords, lookup_tables.nDocs);
    double** dist_mat = mat_init (N, D);
    compute_dist_mat (data, dist_mat, N, D, &lookup_tables);
    cvx_hdp_medoids (dist_mat, LAMBDAs, W, &lookup_tables);

    /* Output objective */
    // output_objective(clustering_objective (dist_mat, W, N));

    /* Output cluster centroids */
    // output_model (W, N);

    /* Output assignment */
    // output_assignment (W, data, N);

    /* reallocation */
    esmat_free (W);
    mat_free (dist_mat, N, D);
}
