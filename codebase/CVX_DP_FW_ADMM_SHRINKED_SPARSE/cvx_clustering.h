/*###############################################################
## MODULE: cvx_clustering.cpp
## VERSION: 1.0 
## SINCE 2014-06-14
## AUTHOR Jimmy Lin (xl5224) - JimmyLin@utexas.edu  
## DESCRIPTION: 
##     This file includes problem-specific data structure and
## utility function.
#################################################################
## Edited by MacVim
## Class Info auto-generated by Snippet 
################################################################*/

#include <cassert>
#include <queue>
#include <time.h>
#include "../util.h"

const double FRANK_WOLFE_TOL = 1e-20;
const double ADMM_EPS = 1e-4;
typedef double (* dist_func) (Instance*, Instance*, int); 
const double r = 10000.0;

class cell {
    public:
        int index;
        double w, z, y, grad; 
        cell () {}
        cell (int i, double w, double z, double y, double grad) {
            this->index = i;
            this->w = w;
            this->z = z;
            this->y = y;
            this->grad = grad;
        }
        void copy_from (cell other) {
            this->index = other.index;
            this->w = other.w;
            this->z = other.z;
            this->y = other.y;
            this->grad = other.grad;

        }
};
bool cell_grad_Comparator (const cell& firstElem, const cell& secondElem) {
    // sort cell by second element with *increasing order* of grad
    return firstElem.grad > secondElem.grad;
}
class CellCompare
{
    public:
        bool operator() (cell obj1, cell obj2)
        {
            return cell_grad_Comparator (obj1, obj2);
        }
};

/* \lambda_g \sumk \maxn |\wnk| */
double compute_group_lasso (Esmat* w, double lambda) {
    if (w->val.size() == 0) 
        return 0.0;
    Esmat* maxn = esmat_init (1, w->nCols);
    Esmat* sumk = esmat_init (1, 1);
    esmat_max_over_col (w, maxn);
    esmat_sum_row (maxn, sumk);
    double lasso = -INF;
    if (sumk->val.size() > 0)
        lasso = lambda * sumk->val[0].second; 
    else 
        lasso = 0.0;
    esmat_free (sumk);
    esmat_free (maxn);
    return lasso;
}

void subproblem_objective (double** dist_mat, Esmat* y, Esmat* z, Esmat* w, double rho, int N, double lambda) {
    Esmat* diff = esmat_init (N, N);
    esmat_zeros (diff);
    // reg = 0.5 * sum_k max_n | w_nk |  -> group-lasso
    double lasso = compute_group_lasso(w, lambda); 
    // loss = 0.5 * sum_n sum_k (w_nk * d^2_nk) -> loss
    double loss = 0.5 * esmat_frob_prod (dist_mat, w);
    // linear = y_1^T dot (w_1 - z) -> linear
    esmat_sub (w, z, diff); // temp = w_1 - z_1
    double linear = esmat_frob_prod (y, diff);
    // quadratic = 0.5 * rho * || w_1 - z_1 ||^2 -> quadratic
    double quadratic = 0.5 * rho * esmat_frob_norm (diff);
    // dummy = r dot (1 - sum_k w_nk) -> dummy
    double dummy_penalty = esmat_compute_dummy (w, r);
    // double total = loss+linear+quadratic+dummy_penalty;
    cout << "(loss, lasso, linear, quadratic, dummy, total) = (" 
        << loss << ", " << lasso << ", " << linear << ", " <<
        quadratic << ", " << dummy_penalty << ")" << endl;
    esmat_free (diff);
    // return total;
}
double overall_objective (double** dist_mat, double lambda, int N, Esmat* z) {
    // N is number of entities in "data", and z is N by N.
    // z is current valid solution (average of w_1 and w_2)
    // STEP ONE: compute 
    //     loss = sum_i sum_j z[i][j] * dist_mat[i][j]
    double loss = 0.5 * esmat_frob_prod(dist_mat, z);
    cout << "loss=" << loss;
    // STEP TWO: compute dummy loss
    // sum4 = r dot (1 - sum_k w_nk) -> dummy
    double dummy_penalty = esmat_compute_dummy (z, r);
    cout << ", dummy= " << dummy_penalty;
    // STEP THREE: compute group-lasso regularization
    double reg = compute_group_lasso (z, lambda); 
    cout << ", reg=" << reg ;
    double overall = loss + reg + dummy_penalty;
    cout << ", overall=" <<  overall << endl;
    return loss + reg;
}

/* Compute the mutual distance of input instances contained within "data" */
void compute_dist_mat (vector<Instance*>& data, Esmat* dist_mat, int N, int D, dist_func df, bool isSym) {
    for (int j = 0; j < N; j ++) {
        Instance * muj = data[j];
        for (int i = 0; i < N; i ++) {
            Instance * xi = data[i];
            double dist_value = df (xi, muj, D);
            dist_mat->val.push_back(make_pair(j*N+i,dist_value));
        }
    }
}
void compute_dist_mat (vector<Instance*>& data, double** dist_mat, int N, int D, dist_func df, bool isSym) {
    for (int i = 0; i < N; i ++) {
        Instance * xi = data[i];
        for (int j = 0; j < N; j ++) {
            Instance * muj = data[j];
            double dist_value = df (xi, muj, D);
            dist_mat[i][j] = dist_value;
        }
    }
}
